import{_ as l,a as d,b as h,c as p}from"./9_future_pages.90b14915.js";import{_ as c,o as u,c as m,b as a,a as e,w as r,d as o,e as g,r as s}from"./app.f10a4800.js";var f="/PolarDB-for-PostgreSQL/assets/2_compute-storage_separation_architecture.150c6ffc.png",y="/PolarDB-for-PostgreSQL/assets/3_HTAP_architecture.43d8e225.png",b="/PolarDB-for-PostgreSQL/assets/4_principles_of_shared_storage.1ff0f380.png",_="/PolarDB-for-PostgreSQL/assets/5_In-memory_page_synchronization.9737c89d.png",P="/PolarDB-for-PostgreSQL/assets/8_solution_to_outdated_pages_LogIndex.b696c625.png",v="/PolarDB-for-PostgreSQL/assets/10_solutions_to_future_pages.f6d8bc5c.png",w="/PolarDB-for-PostgreSQL/assets/11_issues_of_conventional_streaming_replication.79eab5de.png",T="/PolarDB-for-PostgreSQL/assets/12_Replicate_only_metadata_of_WAL_records.092ef5f2.png",L="/PolarDB-for-PostgreSQL/assets/13_optimization1_result.98261cb3.png",A="/PolarDB-for-PostgreSQL/assets/14_optimize_log_apply_of_WAL_records.e19cfea8.png",D="/PolarDB-for-PostgreSQL/assets/15_optimization2_result.5c124fdf.png",x="/PolarDB-for-PostgreSQL/assets/16_optimize_log_apply_of_DDL_locks.0e74ca0c.png",B="/PolarDB-for-PostgreSQL/assets/17_optimization3_result.c08ad12d.png",S="/PolarDB-for-PostgreSQL/assets/18_recovery_optimization_background.a9ce115d.png",W="/PolarDB-for-PostgreSQL/assets/19_lazy_recovery.f16bb60b.png",I="/PolarDB-for-PostgreSQL/assets/20_recovery_optimization_result.80832b6f.png",k="/PolarDB-for-PostgreSQL/assets/21_Persistent_BufferPool.bd6c06a2.png",z="/PolarDB-for-PostgreSQL/assets/22_buffer_pool_structure.a755d484.png",O="/PolarDB-for-PostgreSQL/assets/23_persistent_buffer_pool_result.abf85155.png",C="/PolarDB-for-PostgreSQL/assets/24_principles_of_HTAP.2f3b912c.png",q="/PolarDB-for-PostgreSQL/assets/25_distributed_optimizer.153c6304.png",Q="/PolarDB-for-PostgreSQL/assets/26_parallelism_of_operators.d53ecbd5.png",H="/PolarDB-for-PostgreSQL/assets/27_parallelism_of_operators_result.ab7b692f.png",R="/PolarDB-for-PostgreSQL/assets/28_data_skew.4fce9edd.png",M="/PolarDB-for-PostgreSQL/assets/29_Solve_data_skew_result.d1f5cd26.png",G="/PolarDB-for-PostgreSQL/assets/30_SQL_statement-level_scalability.03086846.png",E="/PolarDB-for-PostgreSQL/assets/31_schedule_workloads.1e37f980.png",N="/PolarDB-for-PostgreSQL/assets/32_transactional_consistency.0f80c9d0.png",F="/PolarDB-for-PostgreSQL/assets/33_TPC-H_performance_Speedup1.bea777d8.png",Y="/PolarDB-for-PostgreSQL/assets/34_TPC-H_performance_Speedup2.57228502.png",j="/PolarDB-for-PostgreSQL/assets/35_TPC-H_performance_Speedup3.6e2b1a40.png",V="/PolarDB-for-PostgreSQL/assets/36_TPC-H_performance_Comparison_with_Greenplum1.265dba6a.png",U="/PolarDB-for-PostgreSQL/assets/37_TPC-H_performance_Comparison_with_Greenplum2.e0571d47.png",X="/PolarDB-for-PostgreSQL/assets/38_Index_creation_accelerated_by_PX.cc3737a1.png",$="/PolarDB-for-PostgreSQL/assets/39_Index_creation_accelerated_by_PX2.0c310510.png",K="/PolarDB-for-PostgreSQL/assets/40_spatio-temporal_databases.8411c32e.png",J="/PolarDB-for-PostgreSQL/assets/41_spatio-temporal_databases_result.33628595.png";const Z={},ee=e("h1",{id:"overview",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#overview","aria-hidden":"true"},"#"),o(" Overview")],-1),ae={class:"table-of-contents"},oe=o("Issues in Conventional Database Systems"),te=o("Benefits of PolarDB"),re=o("A Guide to This Document"),se=o("Compute-Storage Separation"),ie=o("HTAP"),ne=o("PolarDB: Compute-Storage Separation"),le=o("Challenges of Shared Storage"),de=o("Basic Principles of Shared Storage"),he=o("Data Consistency"),pe=o("Low-latency Replication"),ce=o("Recovery Optimization"),ue=o("PolarDB HTAP"),me=o("Basic Principles of HTAP"),ge=o("Distributed Optimizer"),fe=o("Parallelism of Operators"),ye=o("Solve the Issue of Data Skew"),be=o("SQL Statement-level Scalability"),_e=o("Transactional Consistency"),Pe=o("TPC-H Performance: Speedup"),ve=o("TPC-H Performance: Comparison with Greenplum"),we=o("Index Creation Accelerated by Distributed Execution"),Te=o("Multi-model Spatio-temporal Database Accelerated by Distributed, Parallel Execution"),Le=o("Summary"),Ae=g('<p>PolarDB PostgreSQL (hereafter simplified as PolarDB) is a stable, reliable, scalable, highly available, and secure enterprise-grade database service that is independently developed by Alibaba Cloud to help you increase security compliance and cost-effectiveness. PolarDB is compatible with PostgreSQL and Oracle. It runs in a proprietary compute-storage separation architecture of Alibaba Cloud to support the horizontal scaling of the storage and computing capabilities.</p><p>PolarDB can process a mix of online transaction processing (OLTP) workloads and online analytical processing (OLAP) workloads in parallel. PolarDB also provides a wide range of innovative multi-model database capabilities to help you process, analyze, and search for diversified data, such as spatio-temporal, GIS, image, vector, and graph data.</p><p>PolarDB supports various deployment architectures. For example, PolarDB supports compute-storage separation, three-node X-Paxos clusters, and local SSDs.</p><h2 id="issues-in-conventional-database-systems" tabindex="-1"><a class="header-anchor" href="#issues-in-conventional-database-systems" aria-hidden="true">#</a> Issues in Conventional Database Systems</h2><p>If you are using a conventional database system and the complexity of your workloads continues to increase, you may face the following challenges as the amount of your business data grows:</p><ol><li>The storage capacity is limited by the maximum storage capacity of a single host.</li><li>You can increase the read capability of your database system only by creating read-only instances. Each read-only instance must be allocated a specific amount of exclusive storage space, which increases costs.</li><li>The time that is required to create a read-only instance increases due to the increase in the amount of data.</li><li>The latency of data replication between the primary instance and the secondary instance is high.</li></ol><h2 id="benefits-of-polardb" tabindex="-1"><a class="header-anchor" href="#benefits-of-polardb" aria-hidden="true">#</a> Benefits of PolarDB</h2><p><img src="'+l+'" alt="image.png"></p><p>To help you resolve the issues that occur in conventional database systems, Alibaba Cloud provides PolarDB. PolarDB runs in a proprietary compute-storage separation architecture of Alibaba Cloud. This architecture has the following benefits:</p><ol><li>Scalability: Computing is separated from storage. You can flexibly scale out the computing cluster or the storage cluster based on your business requirements.</li><li>Cost-effectiveness: All compute nodes share the same physical storage. This significantly reduces costs.</li><li>Easy to use: Each PolarDB cluster consists of one primary node and one or more read-only nodes to support read/write splitting.</li><li>Reliability: Data is stored in triplicate, and a backup can be finished in seconds.</li></ol><h2 id="a-guide-to-this-document" tabindex="-1"><a class="header-anchor" href="#a-guide-to-this-document" aria-hidden="true">#</a> A Guide to This Document</h2><p>PolarDB is integrated with various technologies and innovations. This document describes the following two aspects of the PolarDB architecture in sequence: compute-storage separation and hybrid transactional/analytical processing (HTAP). You can find and read the content of your interest with ease.</p><ul><li>Compute-storage separation is the foundation of the PolarDB architecture. Conventional database systems run in the shared-nothing architecture, in which each instance is allocated independent computing resources and storage resources. As conventional database systems evolve towards compute-storage separation, database engines developers face challenges in managing executors, transactions, and buffers. PolarDB is designed to help you address these challenges.</li><li>HTAP is designed to support OLAP queries in OLTP scenarios and fully utilize the computing capabilities of multiple read-only nodes. HTAP is achieved by using a shared storage-based massively parallel processing (MPP) architecture. In the shared storage-based MPP architecture, each table or index tree is stored as a whole and is not divided into virtual partitions that are stored on different nodes. This way, you can retain the workflows used in OLTP scenarios. In addition, you can use the shared storage-based MPP architecture without the need to modify your application data.</li></ul><p>This section explains the following two aspects of the PolarDB architecture: compute-storage separation and HTAP.</p><h3 id="compute-storage-separation" tabindex="-1"><a class="header-anchor" href="#compute-storage-separation" aria-hidden="true">#</a> Compute-Storage Separation</h3><p><img src="'+f+'" alt="image.png"></p><p>PolarDB supports compute-storage separation. Each PolarDB cluster consists of a computing cluster and a storage cluster. You can flexibly scale out the computing cluster or the storage cluster based on your business requirements.</p><ol><li>If the computing power is insufficient, you can scale out only the computing cluster.</li><li>If the storage capacity is insufficient, you can scale out only the storage cluster.</li></ol><p>After the shared-storage architecture is used in PolarDB, the primary node and the read-only nodes share the same physical storage. If the primary node still uses the method that is used in conventional database systems to flush write-ahead logging (WAL) records, the following issues may occur.</p><ol><li>The pages that the read-only nodes read from the shared storage are outdated pages. Outdated pages are pages that are of earlier versions than the versions that are recorded on the read-only nodes.</li><li>The pages that the read-only nodes read from the shared storage are future pages. Future pages are pages that are of later versions than the versions that are recorded on the read-only nodes.</li><li>When your workloads are switched over from the primary node to a read-only node, the pages that the read-only node reads from the shared storage are outdated pages. In this case, the read-only node needs to read and apply WAL records to restore dirty pages.</li></ol><p>To resolve the first issue, PolarDB must support multiple versions for each page. To resolve the second issue, PolarDB must control the speed at which the primary node flushes WAL records.</p><h3 id="htap" tabindex="-1"><a class="header-anchor" href="#htap" aria-hidden="true">#</a> HTAP</h3><p>When read/write splitting is enabled, each individual compute node cannot fully utilize the high I/O throughput that is provided by the shared storage. In addition, you cannot accelerate large queries by adding computing resources. To resolve these issues, PolarDB uses the shared storage-based MPP architecture to accelerate OLAP queries in OLTP scenarios.</p><p>PolarDB supports a complete suite of data types that are used in OLTP scenarios. PolarDB also supports two computing engines, which can process these types of data:</p><ul><li>Standalone execution engine: processes highly concurrent OLTP queries.</li><li>Distributed execution engine: processes large OLAP queries.</li></ul><p><img src="'+y+'" alt="image.png"></p><p>When the same hardware resources are used, PolarDB delivers performance that is 90% of the performance delivered by Greenplum. PolarDB also provides SQL statement-level scalability. If the computing power of your PolarDB cluster is insufficient, you can allocate more CPU resources to OLAP queries without the need to rearrange data.</p><p>The following sections provide more details about compute-storage separation and HTAP.</p><h2 id="polardb-compute-storage-separation" tabindex="-1"><a class="header-anchor" href="#polardb-compute-storage-separation" aria-hidden="true">#</a> PolarDB: Compute-Storage Separation</h2><h3 id="challenges-of-shared-storage" tabindex="-1"><a class="header-anchor" href="#challenges-of-shared-storage" aria-hidden="true">#</a> Challenges of Shared Storage</h3><p>Compute-storage separation enables the compute nodes of your PolarDB cluster to share the same physical storage. Shared storage brings the following challenges:</p><ul><li>Data consistency: how to ensure consistency between N copies of data in the computing cluster and 1 copy of data in the storage cluster.</li><li>Read/write splitting: how to replicate data at a low latency.</li><li>High availability: how to perform recovery and failover.</li><li>I/O model: how to optimize the file system from buffered I/O to direct I/O.</li></ul><h3 id="basic-principles-of-shared-storage" tabindex="-1"><a class="header-anchor" href="#basic-principles-of-shared-storage" aria-hidden="true">#</a> Basic Principles of Shared Storage</h3><p><img src="'+b+'" alt="image.png"></p><p>The following basic principles of shared storage apply to PolarDB:</p><ul><li>The primary node can process read requests and write requests. The read-only nodes can process only read requests.</li><li>Only the primary node can write data to the shared storage. This way, the data that you query on the primary node is the same as the data that you query on the read-only nodes.</li><li>The read-only nodes apply WAL records to ensure that the pages in the memory of the read-only nodes are synchronous with the pages in the memory of the primary node.</li><li>The primary node writes WAL records to the shared storage, and only the metadata of the WAL records is replicated to the read-only nodes.</li><li>The read-only nodes read WAL records from the shared storage and apply the WAL records.</li></ul><h3 id="data-consistency" tabindex="-1"><a class="header-anchor" href="#data-consistency" aria-hidden="true">#</a> Data Consistency</h3><h4 id="in-memory-page-synchronization-in-shared-nothing-architecture" tabindex="-1"><a class="header-anchor" href="#in-memory-page-synchronization-in-shared-nothing-architecture" aria-hidden="true">#</a> In-memory Page Synchronization in Shared-nothing Architecture</h4><p>In a conventional database system, the primary instance and read-only instances each are allocated independent memory resources and storage resources. The primary instance replicates WAL records to the read-only instances, and the read-only instances read and apply the WAL records. These basic principles also apply to replication state machines.</p><h4 id="in-memory-page-synchronization-in-shared-storage-architecture" tabindex="-1"><a class="header-anchor" href="#in-memory-page-synchronization-in-shared-storage-architecture" aria-hidden="true">#</a> In-memory Page Synchronization in Shared-storage Architecture</h4><p>In a PolarDB cluster, the primary node replicates WAL records to the shared storage. The read-only nodes read and apply the most recent WAL records from the shared storage to ensure that the pages in the memory of the read-only nodes are synchronous with the pages in the memory of the primary node.</p><p><img src="'+_+'" alt="image.png"></p><ol><li>The primary node flushes the WAL records of a page to write version 200 of the page to the shared storage.</li><li>The read-only nodes read and apply the WAL records of the page to update the page from version 100 to version 200.</li></ol><h4 id="outdated-pages-in-shared-storage-architecture" tabindex="-1"><a class="header-anchor" href="#outdated-pages-in-shared-storage-architecture" aria-hidden="true">#</a> Outdated Pages in Shared-storage Architecture</h4><p>In the workflow shown in the preceding figure, the new page that the read-only nodes obtain by applying WAL records is removed from the buffer pools of the read-only nodes. When you query the page on the read-only nodes, the read-only nodes read the page from the shared storage. As a result, only the previous version of the page is returned. This previous version is called an outdated page. The following figure shows more details.</p><p><img src="'+d+'" alt="image.png"></p><ol><li>At T1, the primary node writes a WAL record with a log sequence number (LSN) of 200 to the memory to update Page 1 from version 500 to version 600.</li><li>At T1, Page 1 on the read-only nodes is in version 500.</li><li>At T2, the primary node sends the metadata of WAL Record 200 to the read-only nodes to notify the read-only nodes of a new WAL record.</li><li>At T3, you query Page 1 on the read-only nodes. The read-only nodes read version 500 of Page 1 and WAL Record 200 and apply WAL Record 200 to update Page 1 from version 500 to version 600.</li><li>At T4, the read-only nodes remove version 600 of Page 1 because their buffer pools cannot provide sufficient space.</li><li>The primary node does not write version 600 of Page 1 to the shared storage. The most recent version of Page 1 in the shared storage is still version 500.</li><li>At T5, you query Page 1 on the read-only nodes. The read-only nodes read Page 1 from the shared storage because Page 1 has been removed from the memory of the read-only nodes. In this case, the outdated version 500 of Page 1 is returned.</li></ol><h4 id="solution-to-outdated-pages" tabindex="-1"><a class="header-anchor" href="#solution-to-outdated-pages" aria-hidden="true">#</a> Solution to Outdated Pages</h4><p>When you query a page on the read-only nodes at a specific point in time, the read-only nodes need to read the base version of the page and the WAL records up to that point in time. Then, the read-only nodes need to apply the WAL records one by one in sequence. The following figure shows more details.</p><p><img src="'+h+'" alt="image.png"></p><ol><li>The metadata of the WAL records of each page is retained in the memory of the read-only nodes.</li><li>When you query a page on the read-only nodes, the read-only nodes need to read and apply the WAL records of the page until the read-only nodes obtain the most recent version of the page.</li><li>The read-only nodes read and apply WAL records from the shared storage based on the metadata of the WAL records.</li></ol><p>PolarDB needs to maintain an inverted index that stores the mapping from each page to the WAL records of the page. However, the memory capacity of each read-only node is limited. Therefore, these inverted indexes must be persistently stored. To meet this requirement, PolarDB provides LogIndex. LogIndex is an index structure, which is used to persistently store hash data.</p><ol><li>The WAL receiver processes of the read-only nodes receive the metadata of WAL records from the primary node.</li><li>The metadata of each WAL record contains information about which page is updated.</li><li>The read-only nodes insert the metadata of each WAL record into a LogIndex structure to generate a LogIndex record. The key of the LogIndex record is the ID of the page that is updated, and the value of the LogIndex record is the LSN of the WAL record.</li><li>One WAL record may contain information about multiple pages that are updated. This process is defined as index block split. If index blocks are split, one WAL record maps multiple LogIndex records.</li><li>The read-only nodes mark each updated page as outdated in their buffer pools. When you query an updated page on the read-only nodes, the read-only nodes can read and apply the WAL records of the page based on the LogIndex records that map the WAL records.</li><li>When the memory usage of the read-only nodes reaches a specific threshold, the hash data that is stored in LogIndex structures is asynchronously flushed from the memory to the disk.</li></ol><p><img src="'+P+'" alt="image.png"></p><p>LogIndex helps prevent outdated pages and enable the read-only nodes to run in lazy log apply mode. In the lazy log apply mode, the read-only nodes apply only the metadata of the WAL records for dirty pages.</p><h4 id="future-pages-in-shared-storage-architecture" tabindex="-1"><a class="header-anchor" href="#future-pages-in-shared-storage-architecture" aria-hidden="true">#</a> Future Pages in Shared-storage Architecture</h4><p>The read-only nodes may return future pages, whose versions are later than the versions that are recorded on the read-only nodes. The following figure shows more details.</p><p><img src="'+p+'" alt="image.png"></p><ol><li>At T1, the primary node updates Page 1 twice from version 500 to version 700. Two WAL records are generated during the update process. The LSN of one WAL record is 200, and the LSN of the other WAL record is 300. At this time, Page 1 is still in version 500 on the primary node and the read-only nodes.</li><li>At T2, the primary node sends WAL Record 200 to the read-only nodes.</li><li>At T3, the read-only nodes apply WAL Record 200 to update Page 1 to version 600. At this time, the read-only nodes have not read or applied WAL Record 300.</li><li>At T4, the primary node writes version 700 of Page 1 to the shared storage. At the same time, Page 1 is removed from the buffer pools of the read-only nodes.</li><li>At T5, the read-only nodes attempt to read Page 1 again. Page 1 cannot be found in the buffer pools of the read-only nodes. Therefore, the read-only nodes obtain version 700 of Page 1 from the shared storage. Version 700 of Page 1 is a future page to the read-only nodes because the read-only nodes have not read or applied WAL Record 300.</li><li>If some of the pages that the read-only nodes obtain from the shared storage are future pages and some are normal pages, data inconsistencies may occur. For example, after an index block is split into two indexes that each map a page, one of the pages the read-only nodes read is a normal page and the other is a future page. In this case, the B+ tree structures of the indexes are damaged.</li></ol><h4 id="solutions-to-future-pages" tabindex="-1"><a class="header-anchor" href="#solutions-to-future-pages" aria-hidden="true">#</a> Solutions to Future Pages</h4><p>The read-only nodes apply WAL records at high speeds in lazy apply mode. However, the speeds may still be lower than the speed at which the primary node flushes WAL records. If the primary node flushes WAL records faster than the read-only nodes apply WAL records, future pages are returned. To prevent future pages, PolarDB must ensure that the speed at which the primary node flushes WAL records does not exceed the speeds at which the read-only nodes apply WAL records. The following figure shows more details.</p><p><img src="'+v+'" alt="image.png"></p><ol><li>The read-only nodes apply the WAL record that is generated at T4.</li><li>When the primary node flushes WAL records to the shared storage, it sorts all WAL records by LSN and flushes only the WAL records that are updated up to T4.</li><li>The file position of the LSN that is generated at T4 is defined as the file position of consistency.</li></ol><h3 id="low-latency-replication" tabindex="-1"><a class="header-anchor" href="#low-latency-replication" aria-hidden="true">#</a> Low-latency Replication</h3><h4 id="issues-of-conventional-streaming-replication" tabindex="-1"><a class="header-anchor" href="#issues-of-conventional-streaming-replication" aria-hidden="true">#</a> Issues of Conventional Streaming Replication</h4><ol><li>The I/O loads on the log synchronization link are heavy, and a large amount of data is transmitted over the network.</li><li>When the read-only nodes process I/O-bound workloads or CPU-bound workloads, they read pages and modify the pages in their buffer pools at low speeds.</li><li>When file- and data-related DDL operations attempt to acquire locks on specific objects, blocking exceptions may occur. As a result, the operations are run at low speeds.</li><li>When the read-only nodes process highly concurrent queries, transaction snapshots are taken at low speeds. The following figure shows more details.</li></ol><p><img src="'+w+'" alt="image.png"></p><ol><li>The primary node writes WAL records to its local file system.</li><li>The WAL sender process of the primary node reads and sends the WAL records to the read-only nodes.</li><li>The WAL receiver processes of the read-only nodes receive and write the WAL records to the local file systems of the read-only nodes.</li><li>The read-only nodes read the WAL records, write the updated pages to their buffer pools, and then apply the WAL records in the memory.</li><li>The primary node flushes the WAL records to the shared storage.</li></ol><p>The full path is long, and the latency on the read-only nodes is high. This may cause an imbalance between the read loads and write loads over the read/write splitting link.</p><h4 id="optimization-method-1-replicate-only-the-metadata-of-wal-records" tabindex="-1"><a class="header-anchor" href="#optimization-method-1-replicate-only-the-metadata-of-wal-records" aria-hidden="true">#</a> Optimization Method 1: Replicate Only the Metadata of WAL Records</h4><p>The read-only nodes can read WAL records from the shared storage. Therefore, the primary node can remove the payloads of WAL records and send only the metadata of WAL records to the read-only nodes. This alleviates the pressure on network transmission and reduces the I/O loads on critical paths. The following figure shows more details.</p><ol><li>Each WAL record consists of three parts: header, page ID, and payload. The header and the page ID comprise the metadata of a WAL record.</li><li>The primary node replicates only the metadata of WAL records to the read-only nodes.</li><li>The read-only nodes read WAL records from the shared storage based on the metadata of the WAL records.</li></ol><p><img src="'+T+'" alt="image.png"></p><p>This optimization method significantly reduces the amount of data that needs to be transmitted between the primary node and the read-only nodes. The amount of data that needs to be transmitted decreases by 98%, as shown in the following figure.</p><p><img src="'+L+'" alt="image.png"></p><h4 id="optimization-method-2-optimize-the-log-apply-of-wal-records" tabindex="-1"><a class="header-anchor" href="#optimization-method-2-optimize-the-log-apply-of-wal-records" aria-hidden="true">#</a> Optimization Method 2: Optimize the Log Apply of WAL Records</h4><p>Conventional database systems need to read a large number of pages, apply WAL records to these pages one by one, and then flush the updated pages to the disk. To reduce the read I/O loads on critical paths, PolarDB supports compute-storage separation. If the page that you query on the read-only nodes cannot be hit in the buffer pools of the read-only nodes, no I/O loads are generated and only LogIndex records are recorded.</p><p>The following I/O operations that are performed by log apply processes can be offloaded to session processes:</p><ol><li>Data page-related I/O operations</li><li>I/O operations to apply WAL records</li><li>I/O operations to apply multiple versions of pages based on LogIndex records</li></ol><p>In the example shown in the following figure, when the log apply process of a read-only node applies the metadata of a WAL record of a page:</p><p><img src="'+A+'" alt="image.png"></p><ol><li>If the page cannot be hit in the memory, only the LogIndex record that maps the WAL record is recorded.</li><li>If the page can be hit in the memory, the page is marked as outdated and the LogIndex record that maps the WAL record is recorded. The log apply process is complete.</li><li>When you start a session process to read the page, the session process reads and writes the most recent version of the page to the buffer pool. Then, the session process applies the WAL record that maps the LogIndex record.</li><li>Major I/O operations are no longer run by a single log apply process. These operations are offloaded to multiple user processes.</li></ol><p>This optimization method significantly reduces the log apply latency and increases the log apply speed by 30 times compared with Amazon Aurora.</p><p><img src="'+D+'" alt="image.png"></p><h4 id="optimization-method-3-optimize-the-log-apply-of-ddl-locks" tabindex="-1"><a class="header-anchor" href="#optimization-method-3-optimize-the-log-apply-of-ddl-locks" aria-hidden="true">#</a> Optimization Method 3: Optimize the Log Apply of DDL Locks</h4><p>When the primary node runs a DDL operation such as DROP TABLE to modify a table, the primary node acquires an exclusive DDL lock on the table. The exclusive DDL lock is replicated to the read-only nodes along with WAL records. The read-only nodes apply the WAL records to acquire the exclusive DDL lock on the table. This ensures that the table cannot be deleted by the primary node when a read-only node is reading the table. Only one copy of the table is stored in the shared storage.</p><p>When the applying process of a read-only node applies the exclusive DDL lock, the read-only node may require a long period of time to acquire the exclusive DDL lock on the table. You can optimize the critical path of the log apply process by offloading the task of acquiring the exclusive DDL lock to other processes.</p><p><img src="'+x+'" alt="image.png"></p><p>This optimization method ensures that the critical path of the log apply process of a read-only node is not blocked even if the log apply process needs to wait for the release of an exclusive DDL lock.</p><p><img src="'+B+'" alt="image.png"></p><p>The three optimization methods in combination significantly reduce replication latency and have the following benefits:</p><ul><li>Read/write splitting: Loads are balanced, which allows PolarDB to deliver user experience that is comparable to Oracle Real Application Clusters (RAC).</li><li>High availability: The time that is required for failover is reduced.</li><li>Stability: The number of future pages is minimized, and fewer or even no page snapshots need to be taken.</li></ul><h3 id="recovery-optimization" tabindex="-1"><a class="header-anchor" href="#recovery-optimization" aria-hidden="true">#</a> Recovery Optimization</h3><h4 id="background-information" tabindex="-1"><a class="header-anchor" href="#background-information" aria-hidden="true">#</a> Background Information</h4><p>If the read-only nodes apply WAL records at low speeds, your PolarDB cluster may require a long period of time to recover from exceptions such as out of memory (OOM) errors and unexpected crashes. When the direct I/O model is used for the shared storage, the severity of this issue increases.</p><p><img src="'+S+'" alt="image.png"></p><h4 id="lazy-recovery" tabindex="-1"><a class="header-anchor" href="#lazy-recovery" aria-hidden="true">#</a> Lazy Recovery</h4><p>The preceding sections explain how LogIndex enables the read-only nodes to apply WAL records in lazy log apply mode. In general, the recovery process of the primary node after a restart is the same as the process in which the read-only nodes apply WAL records. In this sense, the lazy log apply mode can also be used to accelerate the recovery of the primary node.</p><p><img src="'+W+'" alt="image.png"></p><ol><li>The primary node begins to apply WAL records in lazy log apply mode one by one starting from a specific checkpoint.</li><li>After the primary node applies all LogIndex records, the log apply is complete.</li><li>After the recovery is complete, the primary node starts to run.</li><li>The actual log apply workloads are offloaded to the session process that is started after the primary node restarts.</li></ol><p>The example in the following figure shows how the optimized recovery method significantly reduces the time that is required to apply 500 MB of WAL records.</p><p><img src="'+I+'" alt="image.png"></p><h4 id="persistent-buffer-pool" tabindex="-1"><a class="header-anchor" href="#persistent-buffer-pool" aria-hidden="true">#</a> Persistent Buffer Pool</h4><p>After the primary node recovers, a session process may need to apply the pages that the session process reads. When a session process is applying pages, the primary node responds at low speeds for a short period of time. To resolve this issue, PolarDB does not delete pages from the buffer pool of the primary node if the primary node restarts or unexpectedly crashes.</p><p><img src="'+k+'" alt="image.png"></p><p>The shared memory of the database engine consists of the following two parts:</p><ol><li>One part is used to store global structures and ProcArray structures.</li><li>The other part is used to store buffer pool structures. The buffer pool is allocated as a specific amount of named shared memory. Therefore, the buffer pool remains valid after the primary node restarts. However, global structures need to be reinitialized after the primary node restarts.</li></ol><p><img src="'+z+'" alt="image.png"></p><p>Not all pages in the buffer pool of the primary node can be reused. For example, if a process acquires an exclusive lock on a page before the primary node restarts and then unexpectedly crashes, no other processes can release the exclusive lock on the page. Therefore, after the primary node unexpectedly crashes or restarts, it needs to traverse all pages in its buffer pool to identify and remove the pages that cannot be reused. In addition, the recycling of buffer pools depends on Kubernetes.</p><p>This optimized buffer pool mechanism ensures the stable performance of your PolarDB cluster before and after a restart.</p><p><img src="'+O+'" alt="image.png"></p><h2 id="polardb-htap" tabindex="-1"><a class="header-anchor" href="#polardb-htap" aria-hidden="true">#</a> PolarDB HTAP</h2><p>The shared storage of PolarDB is organized as a storage pool. When read/write splitting is enabled, the theoretical I/O throughput that is supported by the shared storage is infinite. However, large queries can be run only on individual compute nodes, and the CPU, memory, and I/O specifications of a single compute node are limited. Therefore, a single compute node cannot fully utilize the high I/O throughput that is supported by the shared storage or accelerate large queries by acquiring more computing resources. To resolve these issues, PolarDB uses the shared storage-based MPP architecture to accelerate OLAP queries in OLTP scenarios.</p><h3 id="basic-principles-of-htap" tabindex="-1"><a class="header-anchor" href="#basic-principles-of-htap" aria-hidden="true">#</a> Basic Principles of HTAP</h3><p>In a PolarDB cluster, the physical storage is shared among all compute nodes. Therefore, you cannot use the method of scanning tables in conventional MPP databases to scan tables in PolarDB clusters. PolarDB supports MPP on standalone execution engines and provides optimized shared storage. This shared storage-based MPP architecture is the first architecture of its kind in the industry. We recommend that you familiarize yourself with following basic principles of this architecture before you use PolarDB:</p><ol><li>The Shuffle operator masks the data distribution.</li><li>The ParallelScan operator masks the shared storage.</li></ol><p><img src="'+C+'" alt="image.png"></p><p>The preceding figure shows an example.</p><ol><li>Table A and Table B are joined and aggregated.</li><li>Table A and Table B are still individual tables in the shared storage. These tables are not physically partitioned.</li><li>Four types of scan operators are redesigned to scan tables in the shared storage as virtual partitions.</li></ol><h3 id="distributed-optimizer" tabindex="-1"><a class="header-anchor" href="#distributed-optimizer" aria-hidden="true">#</a> Distributed Optimizer</h3><p>The GPORCA optmizer is extended to provide a set of transformation rules that can recognize shared storage. The GPORCA optimizer enables PolarDB to access a specific amount of planned search space. For example, PolarDB can scan a table as a whole or as different virtual partitions. This is a major difference between shared storage-based MPP and conventional MPP.</p><p>The modules in gray in the upper part of the following figure are modules of the database engine. These modules enable the database engine of PolarDB to adapt to the GPORCA optimizer.</p><p>The modules in the lower part of the following figure comprise the GPORCA optimizer. Among these modules, the modules in gray are extended modules, which enable the GPORCA optimizer to communicate with the shared storage of PolarDB.</p><p><img src="'+q+'" alt="image.png"></p><h3 id="parallelism-of-operators" tabindex="-1"><a class="header-anchor" href="#parallelism-of-operators" aria-hidden="true">#</a> Parallelism of Operators</h3><p>Four types of operators in PolarDB require parallelism. This section describes how to enable parallelism for operators that are used to run sequential scans. To fully utilize the I/O throughput that is supported by the shared storage, PolarDB splits each table into logical units during a sequential scan. Each unit contains 4 MB of data. This way, PolarDB can distribute I/O loads to different disks, and the disks can simultaneously scan data to accelerate the sequential scan. In addition, each read-only node needs to scan only specific tables rather than all tables. The size of tables that can be cached is the total size of the buffer pools of all read-only nodes.</p><p><img src="'+Q+'" alt="image.png"></p><p>Parallelism has the following benefits, as shown in the following figure:</p><ol><li>You can increase scan performance by 30 times by creating read-only nodes.</li><li>You can reduce the time that is required for a scan from 37 minutes to 3.75 seconds by enabling the buffering feature.</li></ol><p><img src="'+H+'" alt="image.png"></p><h3 id="solve-the-issue-of-data-skew" tabindex="-1"><a class="header-anchor" href="#solve-the-issue-of-data-skew" aria-hidden="true">#</a> Solve the Issue of Data Skew</h3><p>Data skew is a common issue in conventional MPP:</p><ol><li>In PolarDB, large objects reference TOAST tables by using heap tables. You cannot balance loads even if you shard TOAST tables or heap tables.</li><li>In addition, the transactions, buffer pools, network connections, and I/O loads of the read-only nodes jitter.</li><li>The preceding issues cause long-tail processes.</li></ol><p><img src="'+R+'" alt="image.png"></p><ol><li>The coordinator node consists of two parts: DataThread and ControlThread.</li><li>DataThread collects and aggregates tuples.</li><li>ControlThread controls the scan progress of each scan operator.</li><li>A worker thread that scans data at a high speed can scan more logical data shards.</li><li>The affinity of buffers must be considered.</li></ol><p>Although a scan task is dynamically distributed, we recommend that you maintain the affinity of buffers at your best. In addition, the context of each operator is stored in the private memory of the worker threads. The coordinator node does not store the information about specific tables.</p><p>In the example shown in the following table, PolarDB uses static sharding to shard large objects. During the static sharding process, data skew occurs, but the performance of dynamic scanning can still linearly increase.</p><p><img src="'+M+'" alt="image.png"></p><h2 id="sql-statement-level-scalability" tabindex="-1"><a class="header-anchor" href="#sql-statement-level-scalability" aria-hidden="true">#</a> SQL Statement-level Scalability</h2><p>Data sharing helps deliver ultimate scalability in cloud-native environments. The full path of the coordinator node involves various modules, and PolarDB can store the external dependencies of these modules to the shared storage. In addition, the full path of a worker thread involves a number of operational parameters, and PolarDB can synchronize these parameters from the coordinator node over the control path. This way, the coordinator node and the worker thread are stateless.</p><p><img src="'+G+'" alt="image.png"></p><p>The following conclusions are made based on the preceding analysis:</p><ol><li>All read-only nodes that run SQL joins can function as coordinator nodes. Therefore, the performance of PolarDB is no longer limited due to the availability of only a single coordinator node.</li><li>Each SQL statement can start any number of worker threads on any compute node. This increases the computing power and allows you to schedule your workloads in a more flexible manner. You can configure PolarDB to simultaneously run different kinds of workloads on different compute nodes.</li></ol><p><img src="'+E+'" alt="image.png"></p><h3 id="transactional-consistency" tabindex="-1"><a class="header-anchor" href="#transactional-consistency" aria-hidden="true">#</a> Transactional Consistency</h3><p>The log apply wait mechanism and the global snapshot mechanism are used to ensure data consistency among multiple compute nodes. The log apply wait mechanism ensures that all worker threads can obtain the most recent version of each page. The global snapshot mechanism ensures that a unified version of each page can be selected.</p><p><img src="'+N+'" alt="image.png"></p><h3 id="tpc-h-performance-speedup" tabindex="-1"><a class="header-anchor" href="#tpc-h-performance-speedup" aria-hidden="true">#</a> TPC-H Performance: Speedup</h3><p><img src="'+F+'" alt="image.png"></p><p>A total of 1 TB of data is used for TPC-H testing. First, run 22 SQL statements in a PolarDB cluster and in a conventional database system. The PolarDB cluster supports distributed parallelism, and the conventional database system supports standalone parallelism. The test result shows that the PolarDB cluster executes three SQL statements at speeds that are 60 times higher and 19 statements at speeds that are 10 times higher than the conventional database system.</p><p><img src="'+Y+'" alt="image.png"></p><p><img src="'+j+'" alt="image.png"></p><p>Then, run a TPC-H test by using a distributed execution engine. The test result shows that the speed at which each of the 22 SQL statements runs linearly increases as the number of cores increases from 16 to 128.</p><h3 id="tpc-h-performance-comparison-with-greenplum" tabindex="-1"><a class="header-anchor" href="#tpc-h-performance-comparison-with-greenplum" aria-hidden="true">#</a> TPC-H Performance: Comparison with Greenplum</h3><p>When 16 nodes are configured, PolarDB delivers performance that is 90% of the performance delivered by MPP-based Greenplum.</p><p><img src="'+V+'" alt="image.png"></p><p><img src="'+U+'" alt="image.png"></p><p>As mentioned earlier, the distributed execution engine of PolarDB supports scalability, and data in PolarDB does not need to be redistributed. When the degree of parallelism (DOP) is 8, PolarDB delivers performance that is 5.6 times the performance delivered by Greenplum.</p><h3 id="index-creation-accelerated-by-distributed-execution" tabindex="-1"><a class="header-anchor" href="#index-creation-accelerated-by-distributed-execution" aria-hidden="true">#</a> Index Creation Accelerated by Distributed Execution</h3><p>A large number of indexes are created in OLTP scenarios. The workloads that you run to create these indexes are divided into two parts: 80% of the workloads are run to sort and create index pages, and 20% of the workloads are run to write index pages. Distributed execution accelerates the process of sorting indexes and supports the batch writing of index pages.</p><p><img src="'+X+'" alt="image.png"> Distributed execution accelerates the creation of indexes by four to five times.</p><p><img src="'+$+'" alt="image.png"></p><h3 id="multi-model-spatio-temporal-database-accelerated-by-distributed-parallel-execution" tabindex="-1"><a class="header-anchor" href="#multi-model-spatio-temporal-database-accelerated-by-distributed-parallel-execution" aria-hidden="true">#</a> Multi-model Spatio-temporal Database Accelerated by Distributed, Parallel Execution</h3><p>PolarDB is a multi-model database service that supports spatio-temporal data. PolarDB runs CPU-bound workloads and I/O-bound workloads. These workloads can be accelerated by distributed execution. The shared storage of PolarDB supports scans on shared R-tree indexes.</p><p><img src="'+K+'" alt="image.png"></p><ul><li>Data volume: 400 million data records, which amount to 500 GB in total</li><li>Configuration: 5 read-only nodes, each of which provides 16 cores and 128 GB of memory</li><li>Performance: <ul><li>Linearly increases with the number of cores.</li><li>Increases by <strong>71 times</strong> when the number of cores increases from 16 to 80.</li></ul></li></ul><p><img src="'+J+'" alt="image.png"></p><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary" aria-hidden="true">#</a> Summary</h2><p>This document describes the crucial technologies that are used in the PolarDB architecture:</p><ul><li>Compute-storage separation</li><li>HTAP</li></ul><p>More technical details about PolarDB will be discussed in other documents. For example, how the shared storage-based query optimizer runs, how LogIndex achieves high performance, how PolarDB flashes your data back to a specific point in time, how MPP can be implemented in the shared storage, and how PolarDB works with X-Paxos to ensure high availability.</p>',171);function De(i,xe){const n=s("ArticleInfo"),t=s("router-link");return u(),m("div",null,[ee,a(n,{frontmatter:i.$frontmatter},null,8,["frontmatter"]),e("nav",ae,[e("ul",null,[e("li",null,[a(t,{to:"#issues-in-conventional-database-systems"},{default:r(()=>[oe]),_:1})]),e("li",null,[a(t,{to:"#benefits-of-polardb"},{default:r(()=>[te]),_:1})]),e("li",null,[a(t,{to:"#a-guide-to-this-document"},{default:r(()=>[re]),_:1}),e("ul",null,[e("li",null,[a(t,{to:"#compute-storage-separation"},{default:r(()=>[se]),_:1})]),e("li",null,[a(t,{to:"#htap"},{default:r(()=>[ie]),_:1})])])]),e("li",null,[a(t,{to:"#polardb-compute-storage-separation"},{default:r(()=>[ne]),_:1}),e("ul",null,[e("li",null,[a(t,{to:"#challenges-of-shared-storage"},{default:r(()=>[le]),_:1})]),e("li",null,[a(t,{to:"#basic-principles-of-shared-storage"},{default:r(()=>[de]),_:1})]),e("li",null,[a(t,{to:"#data-consistency"},{default:r(()=>[he]),_:1})]),e("li",null,[a(t,{to:"#low-latency-replication"},{default:r(()=>[pe]),_:1})]),e("li",null,[a(t,{to:"#recovery-optimization"},{default:r(()=>[ce]),_:1})])])]),e("li",null,[a(t,{to:"#polardb-htap"},{default:r(()=>[ue]),_:1}),e("ul",null,[e("li",null,[a(t,{to:"#basic-principles-of-htap"},{default:r(()=>[me]),_:1})]),e("li",null,[a(t,{to:"#distributed-optimizer"},{default:r(()=>[ge]),_:1})]),e("li",null,[a(t,{to:"#parallelism-of-operators"},{default:r(()=>[fe]),_:1})]),e("li",null,[a(t,{to:"#solve-the-issue-of-data-skew"},{default:r(()=>[ye]),_:1})])])]),e("li",null,[a(t,{to:"#sql-statement-level-scalability"},{default:r(()=>[be]),_:1}),e("ul",null,[e("li",null,[a(t,{to:"#transactional-consistency"},{default:r(()=>[_e]),_:1})]),e("li",null,[a(t,{to:"#tpc-h-performance-speedup"},{default:r(()=>[Pe]),_:1})]),e("li",null,[a(t,{to:"#tpc-h-performance-comparison-with-greenplum"},{default:r(()=>[ve]),_:1})]),e("li",null,[a(t,{to:"#index-creation-accelerated-by-distributed-execution"},{default:r(()=>[we]),_:1})]),e("li",null,[a(t,{to:"#multi-model-spatio-temporal-database-accelerated-by-distributed-parallel-execution"},{default:r(()=>[Te]),_:1})])])]),e("li",null,[a(t,{to:"#summary"},{default:r(()=>[Le]),_:1})])])]),Ae])}var We=c(Z,[["render",De],["__file","arch-overview.html.vue"]]);export{We as default};
